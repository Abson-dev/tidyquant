---
title: "Introduction to tidyquant"
author: "Matt Dancho"
date: "`r Sys.Date()`"
output: 
  rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

> Bringing quantitative financial analysis to the tidyverse

# Overview

The purpose of `tidyquant` is to integrate the best quantitative resources for collecting and analyzing quantitative data, `xts`, `quantmod` and `TTR`, with the tidy data infrastructure of the `tidyverse`. The [tidy data principles](https://www.jstatsoft.org/article/view/v059i10) are a cornerstone of data management and data modeling workflow. The foundation for tidy data management is the `tidyverse`, a collection of _R packages_ that work in harmony and are well documented in [R for Data Science](http://r4ds.had.co.nz/). Using this infrastructure and the core tidy concepts, we can apply the tidy data principles to quantitative financial analysis. 

# Prerequisites

```{r, echo = FALSE, message = FALSE, warning = FALSE}
knitr::opts_chunk$set(message = FALSE,
                      warning = FALSE,
                      fig.width = 6)
devtools::load_all()
```

Load the following packages to get started.

```{r}
library(tidyquant)  # tidyquant, tidyverse, xts, quantmod, TTR 
```

# Benefits

The `tidyquant` philosophy:

* [A few core functions with a lot of power](#core-functions), that 
* [leverage the quantitative analysis power of `xts`, `quantmod` and `TTR`](#quant-power), that are
* [built to be scaled with the `tidyverse` workflow](#built-for-scale).

<a class="anchor" id="core-functions"></a>

## A Few Core Functions with A Lot of Power

Minimizing the number of functions reduces the learning curve. Functions are grouped into verbs for efficient collection and manipulation of quantitative data: 

* __Get Quantitative Data, `tq_get()`:__ A one-stop shop to get data from various web-sources.  

* __Transform, `tq_transform()`, and Mutate, `tq_mutate()`, Quantitative Data: __ These are the workhorse functions that wrap around the `xts`, `quantmod`, and `TTR` packages. 

* __Coerce Quantitative Data Between tibble and xts formats, `as_tibble()` and `as_xts()`:__ Coercing `xts`, `zoo`, `timeSeries`, and the other various _R_ time-based objects to and from `tibble` or `data.frame` objects was a pain due to the date/time being stored as row names in time-based objects. The tidyquant `as_tibble()` and `as_xts()` functions enable preservation of row names during coercion.

### Get Quantitative Data

The `tq_get()` function is used to collect all data by changing the `get` argument. The options include stock lists for 18 stock indexes from marketvolume.com, stock prices, dividends and splits from Yahoo Finance, financial statements from Google Finance, metal prices and exchange rates from Oanda, and economic data from the FRED database.

__Stock Index:__

A wide range of stock index / exchange lists can be retrieved using `get = "stock.index"`. To get a full list of the options, set `x = "options"`. 

```{r}
tq_get("options", get = "stock.index")
```

Set `x` as one of the options in the list of options above, and `get = "stock.index"` to get the desired stock index / exchange.

```{r}
tq_get("sp500", get = "stock.index")
```

The data source is [www.marketvolume.com](http://www.marketvolume.com/indexes_exchanges/).

__Stock Prices, Dividends and Splits:__

The stock prices can be retrieved succinctly using `get = "stock.prices"`.  

```{r}
appl_prices  <- tq_get("AAPL", get = "stock.prices", from = " 1990-01-01")
appl_prices 
```


Dividends are easily obtained using `get = "dividends"`. 

```{r}
appl_divs <- tq_get("AAPL", get = "dividends", from = "1990-01-01")
appl_divs
```

Stock splits are easily obtained using `get = "splits"`. 

```{r}
appl_splits <- tq_get("AAPL", get = "splits", from = "1990-01-01")
appl_splits
```

The data source is [yahoo finance](https://finance.yahoo.com/).

__Financial Statements:__

For any given stock, a total of six financials statements are retrieved as nested tibbles, one for each combination of statement type (Income Statement, Balance Sheet, and Cash Flow) and period (by annual and quarter). 

```{r}
fb_financials <- tq_get("FB", get = "financials")
fb_financials
```

The statement information can be extracted by selecting (`dplyr::select()`) and filtering (`dplyr::filter()`) to the desired statement and unnesting (`tidyr::unnest()`) the results.

```{r}
fb_financials %>%
    filter(type == "IS") %>%
    select(annual) %>%
    unnest()
```

A slightly more powerful example is looking at all quarterly statements together. This is easy to do with `unnest` and `spread` from the `tidyr` package.

```{r}
fb_financials %>%
    tidyr::unnest(quarter) %>% 
    tidyr::spread(key = date, value = value)
```


The data source is [google finance](https://www.google.com/finance).


<a class="anchor" id="economic-data"></a>
__Economic Data: __ 

A wealth of economic data can be extracted from the Federal Reserve Economic Data (FRED) database. The [WTI Crude Oil Prices](https://fred.stlouisfed.org/series/DCOILWTICO) are shown below.

```{r,}
wti_price_usd <- tq_get("DCOILWTICO", get = "economic.data")
wti_price_usd %>%
    ggplot(aes(x = date, y = price)) +
    geom_line() + 
    ggtitle("WTI Crude Prices")
```


The FRED contains litteraly over 10K data sets that are free to use. See the [FRED categories](https://fred.stlouisfed.org/categories) to narrow down the data base and to get data codes. 


__Exchange Rates:__

Exchange rates are entered as currency pairs using "/" notation (e.g `"EUR/USD"`), and by setting `get = "exchange.rates"`. 

```{r}
eur_usd <- tq_get("EUR/USD", get = "exchange.rates", from = "2000-01-01")
eur_usd %>%
    ggplot(aes(x = date, y = exchange.rate)) +
    geom_line() + 
    ggtitle("EUR/USD Exchange Rate")
```

The data source is [Oanda](https://www.oanda.com/), and list of currencies to compare can be found on [Oanda's currency converter](https://www.oanda.com/currency/converter/). It may make more sense to get this data from the FRED (See [Economic Data](#economic-data)) since the max period for Oanda is 5-years.

__Metal Prices:__

Metal prices are very similar to stock prices. Set `get = "metal.prices"` along with the appropriate commodity symbol (e.g. XAU (gold) , XAG (silver), XPD (palladium), or XPT (platinum)). 

```{r}
plat_price_eur <- tq_get("plat", get = "metal.prices", 
                         from = "2000-01-01", base.currency = "EUR")
plat_price_eur %>%
    ggplot(aes(x = date, y = price)) +
    geom_line() + 
    ggtitle("Platinum Prices (EUR)")
```

The data source is [Oanda](https://www.oanda.com/). It may make more sense to get this data from the FRED (See [Economic Data](#economic-data)) since the max period for Oanda is 5-years.

### Transform and Mutate Quantitative Data

Transform and mutate functions enable the `xts`, `quantmod` and `TTR` functions to shine (see [Leverage the Quantitative Power of `xts`, `quantmod` and `TTR`](#quant-power)):

__Transform Quantitative Data, `tq_transform()`:__ Transforms the results of `tq_get()`. The result is typically a different shape than the input (hence "transformed"). An example is periodicity aggregation from daily to monthly.

```{r}
fb_prices <- tq_get("FB") 
fb_prices %>%
    tq_transform(x_fun = OHLCV, transform_fun = to.monthly, OHLC = FALSE)
```

`x_fun` is one of the various quantmod Open, High, Low, Close (OHLC) functions (see `?quantmod::OHLC`). The function returns a column or set of columns from data that are passed to the `transform_fun`. In example above, `OHLCV` selects the full list of prices and volumes from `data`, and sends this to the transform function, `to.monthly`, which transforms the periodicity from daily to monthly. Additional arguments can be passed to the `transform_fun` by way of `...`. Setting `OHLC = FALSE` is an example of this, which prevents `xts::to.monthly` from converting the results to OHLCV (we do this to prevent xts renaming the columns, see documentation `?to.monthly`). 


__Mutate Quantitative Data, `tq_mutate()`:__ Adds a column or set of columns to the tibble with the calculated attributes (hence the original tibble is returned, mutated with the additional columns). An example is getting the `MACD` from `Cl` (close price), which mutates the original input by adding MACD and Signal columns. 

```{r}
fb_prices %>%
    tq_mutate(x_fun = Cl, mutate_fun = MACD)
```

__xy Variants, `tq_transform_xy` and `tq_mutate_xy`:__ Enables working with (1) transformation functions that require two primary inputs (e.g. EVWMA, VWAP, etc) and (2) data that is not in OHLC format. 

_Transformation with two primary inputs: _

EVWMA (exponential volume-weighted moving average)

```{r, message=FALSE, warning=FALSE}
fb_prices %>%
    tq_mutate_xy(.x = close, .y = volume, mutate_fun = EVWMA)
```

_Working with non-OHLC data: _

Transforming WTI Crude daily prices to monthly prices.

```{r, message=FALSE, warning=FALSE}
wti_prices <- tq_get("DCOILWTICO", get = "economic.data") 
wti_prices %>%    
    tq_transform_xy(.x = price, transform_fun = to.period,
                    period = "months", OHLC = FALSE)
```


### Coercing Time Series Objects to Tibble

The `tidyquant::as_tibble()` function includes a `preserve_row_names` argument, which is useful when coercing one of the many time formats (e.g. `xts`, `zoo`, `timeSeries`, `ts`) or `matrix` objects that contain valuable information in the row names. This makes bridging the gap between the various quantitative analysis packages and the `tidyverse` much easier.

Let's start with an `xts` object.

```{r}
# Create xts object from a matrix
vals = matrix(c(500, 504, 503))
date = c("2016-01-01", "2016-01-02", "2016-01-03") 
rownames(vals) <- date
time_series_xts <- xts::as.xts(vals)
time_series_xts
```

We can easily coerce to `tibble` by setting `preserve_row_names = TRUE`. Note the return column is `row.names` with class of `character`.

```{r}
time_series_tbl <- tidyquant::as_tibble(time_series_xts, preserve_row_names = TRUE)
time_series_tbl
```

Converting to date is one extra step with `lubridate`.

```{r}
time_series_tbl <- time_series_tbl %>%
    mutate(row.names = lubridate::ymd(row.names))
time_series_tbl
```

And we can even convert back to `xts` with the tidyquant `as_xts()` function. Make sure to set the date column argument to the column name containing the date (`date_col = row.names`).

```{r}
time_series_xts <- time_series_tbl %>%
    as_xts(date_col = row.names)
time_series_xts
```

<a class="anchor" id="quant-power"></a>

## Leverage the Quantitative Power of `xts`, `quantmod` and `TTR`

You may already know and love `xts`, `quantmod` and `TTR`, which is why the core functionality is fully intact. Using `tq_transform()` and `tq_mutate()`, we can apply the `xts`, `quantmod` and `TTR` functions. Entering `tq_transform_fun_options()` returns a list the transform functions by each package. We'll discuss these options by package briefly.

```{r}
tq_transform_fun_options() %>% str()
```


### xts Functionality


```{r}
# Get xts functions that work with tq_transform and tq_mutate
tq_transform_fun_options()$xts
```

The `xts` functions that are compatible are listed above. Generally speaking, these are the:

* period.apply functions:
    * Apply a function to a time segment (e.g. `max`, `min`, `mean`, etc).
    * Form: `apply.daily(x, FUN, ...)`.
    * Options include apply.daily, weekly, monthly, quarterly, yearly.

* to.period functions:
    * Convert a time series to time series of lower periodicity (e.g. convert daily to monthly periodicity).
    * Form: `to.period(x, period = 'months', k = 1, indexAt, name = NULL, OHLC = TRUE, ...)`.
    * Options include to.minutes, hourly, daily, weekly, monthly, quarterly, yearly. 


### quantmod Functionality

```{r}
# Get quantmod functions that work with tq_transform and tq_mutate
tq_transform_fun_options()$quantmod
```

The `quantmod` functions that are compatible are listed above. Generally speaking, these are the:

* Delt functions
    * Delt
    * Lag / Next
    * ClCl, HiCl, LoCl, LoHi, OpCl, OpHi, OpLo, OpOp

* periodReturn functions: Get the arithmetic or logarithmic returns for various periodicities, which include daily, weekly, monthly, quarterly, and yearly.

* series functions: Return values that describe the series. Options include describing the increases/decreases, accelerations/decelerations, and hi/low.

### TTR Functionality

```{r}
# Get TTR functions that work with tq_transform and tq_mutate
tq_transform_fun_options()$TTR
```


Here' a brief description of the most popular functions from `TTR`:

* Welles Wilder's Directional Movement Index: 
    *  `ADX(HLC, n = 14, maType, ...)`
* Bollinger Bands: 
    *  `BBands(HLC, n = 20, maType, sd = 2, ...)`: Bollinger Bands
* Rate of Change / Momentum: 
    * `ROC(x, n = 1, type = c("continuous", "discrete"), na.pad = TRUE)`: Rate of Change
    * `momentum(x, n = 1, na.pad = TRUE)`: Momentum
* Moving Averages (maType):
    * `SMA(x, n = 10, ...)`: Simple Moving Average
    * `EMA(x, n = 10, wilder = FALSE, ratio = NULL, ...)`: Exponential Moving Average
    * `DEMA(x, n = 10, v = 1, wilder = FALSE, ratio = NULL)`: Double Exponential Moving Average
    * `WMA(x, n = 10, wts = 1:n, ...)`: Weighted Moving Average
    * `EVWMA(price, volume, n = 10, ...)`: Elastic, Volume-Weighted Moving Average
    * `ZLEMA(x, n = 10, ratio = NULL, ...)`: Zero Lag Exponential Moving Average
    * `VWAP(price, volume, n = 10, ...)`: Volume-Weighted Moving Average Price
    * `VMA(x, w, ratio = 1, ...)`: Variable-Length Moving Average
    * `HMA(x, n = 20, ...)`: Hull Moving Average
    * `ALMA(x, n = 9, offset = 0.85, sigma = 6, ...)`: Arnaud Legoux Moving Average
* MACD Oscillator: 
    *  `MACD(x, nFast = 12, nSlow = 26, nSig = 9, maType, percent = TRUE, ...)`
* Relative Strength Index: 
    *  `RSI(price, n = 14, maType, ...)`
* runFun: 
    * `runSum(x, n = 10, cumulative = FALSE)`: returns sums over a n-period moving window.
    * `runMin(x, n = 10, cumulative = FALSE)`: returns minimums over a n-period moving window.
    * `runMax(x, n = 10, cumulative = FALSE)`: returns maximums over a n-period moving window.
    * `runMean(x, n = 10, cumulative = FALSE)`: returns means over a n-period moving window.
    * `runMedian(x, n = 10, non.unique = "mean", cumulative = FALSE)`: returns medians over a n-period moving window.
    * `runCov(x, y, n = 10, use = "all.obs", sample = TRUE, cumulative = FALSE)`: returns covariances over a n-period moving window.
    * `runCor(x, y, n = 10, use = "all.obs", sample = TRUE, cumulative = FALSE)`: returns correlations over a n-period moving window.
    * `runVar(x, y = NULL, n = 10, sample = TRUE, cumulative = FALSE)`: returns variances over a n-period moving window.
    * `runSD(x, n = 10, sample = TRUE, cumulative = FALSE)`: returns standard deviations over a n-period moving window.
    * `runMAD(x, n = 10, center = NULL, stat = "median", constant = 1.4826, non.unique = "mean", cumulative = FALSE)`: returns median/mean absolute deviations over a n-period moving window.
    * `wilderSum(x, n = 10)`: retuns a Welles Wilder style weighted sum over a n-period moving window.
* Stochastic Oscillator / Stochastic Momentum Index:
    * `stoch(HLC, nFastK = 14, nFastD = 3, nSlowD = 3, maType, bounded = TRUE, smooth = 1, ...)`: Stochastic Oscillator
    * `SMI(HLC, n = 13, nFast = 2, nSlow = 25, nSig = 9, maType, bounded = TRUE, ...)`: Stochastic Momentum Index


### Quantitative Power In Action



#### Example 1: Getting the max close price for each quarter.

The `xts::apply.quarterly()` function that is part of the period apply group can be used to apply functions by quarterly time segments. Because we are seeking a return structure that is on a different time scale than the input (quarterly versus daily), we need to use a transform function. We select `tq_transform` and pass the close price using OHLC format via `x_fun = Cl`, and we send this subset of the data to the `apply.quarterly` function via the `transform_fun` argument. Looking at the documentation for `apply.quarterly`, we see that we can pass a function to the argument, `FUN`. We want the maximum values, so we set `FUN = max`. The result is the quarters returned as a date and the maximum closing price during the quarter returned as a double. 

```{r}
tq_get("AAPL", get = "stock.prices") %>%
    tq_transform(x_fun = Cl, transform_fun = apply.quarterly, FUN = max)
```

Note that as an alternative you could use the xy form, replacing `x_fun = Cl` with `.x = close`.

#### Example 2: Getting daily log returns 

The `quantmod::periodReturn()` function generates returns by periodicity. We have a few options here. Normally I go with a transform function, `tq_transform`, because the periodReturn function accepts different periodicity options, and anything other than daily will blow up a mutation. But, in our situation the periodicity is the same as the stock prices periodicity (both daily), so we can use either. We want to use the adjusted column, so we set `x_fun = Ad`. We researched the `periodReturn` function, and we found that it accepts `type = "log"` and `period = "daily"`, which returns the daily log returns. 


```{r}
tq_get("AAPL", get = "stock.prices") %>%
    tq_transform(x_fun = Ad, transform_fun = periodReturn, 
                 type = "log", period = "daily")
```

#### Example 3: Adding MACD and Bollinger Bands to a OHLC data set

In reviewing the available options in the `TTR` package, we see that `MACD` and `BBands` functions will get us where we need to be. In researching the documentation, the return is in the same periodicty as the input and the functions work with OHLC functions, so we can use `tq_mutate()`. MACD requires a price, so we select close using `Cl`, BBands requires high, low, and close, prices so we use `HLC`. We can chain the inputs together using the pipe (`%>%`) since mutate just adds columns. The result is a tibble containing the MACD and Bollinger Band results. 

```{r}
tq_get("AAPL") %>%
    tq_mutate(Cl, MACD) %>%
    tq_mutate(HLC, BBands)
```

Note that for the MACD, we could have used `tq_mutate_xy()`, setting `.x = close`. However, for the BBands, we are forced to use `tq_mutate()` because of the HLC input.

<a class="anchor" id="built-for-scale"></a>

## Built to be Scaled with the `tidyverse` Workflow

Each function has one primary input and one output. This allows chaining operations with the pipe (`%>%`), and mapping to extend to lists of many stocks, exchange rates, metals, economic data, financial statements, etc. The rationale behind this is simple: let the function handle the operation, let the `tidyverse` handle the iteration. 

It's often important to compare stocks to determine which are the best investments. Using the `tidyverse`, we setup a two step process:

1. Analyze a single stock
2. Extrapolate to many stocks

### Analyze a Single Stock

In our hypothetical situation, we want to compare the mean of the monthly log returns (MMLR). First, let's come up with a function to help us collect log returns.

```{r}
my_stock_analysis_fun <- function(stock.symbol) {
    stock.symbol %>%
        tq_get(get = "stock.prices") %>%
        tq_transform(x_fun = Ad, transform_fun = periodReturn, 
                     type = "log", period = "monthly")
}
```

And, let's test it out.

```{r}
my_stock_analysis_fun("AAPL")
```

The workflow to get the MMLR for a single stock:

```{r}
period_returns <- my_stock_analysis_fun("AAPL") 
mean(period_returns$monthlyreturns)
```



### Extrapolate to Many Stocks using `tidyverse`

Now that we have one stock down, we can scale to many stocks. For brevity, we'll randomly sample ten stocks from the S&amp;P500.

```{r}
set.seed(100)
stocks <- tq_get("SP500", get = "stock.index") %>%
    dplyr::sample_n(10)
stocks
```

We can now apply our analysis function to the stocks using `dplyr::mutate` and `purrr::map`.

```{r}
stocks <- stocks %>%
    dplyr::mutate(period.returns = purrr::map(symbol, my_stock_analysis_fun)) %>%
    dplyr::mutate(mmlr = purrr::map_dbl(period.returns, ~ mean(.$monthlyreturns))) %>%
    dplyr::arrange(desc(mmlr))
stocks
```



### Functions Return NA on Error By Design


Pros: Long running scripts are not interrupted because of one 

Cons: Errors can go unnoticed if not looking at warnings and not reviewing results



# Recap

Hopefully now you see how `tidyquant` helps to bring quantative analytics to the `tidyverse`. The benefits are:

* A few core functions with a lot of power, that 
* leverage the quantitative analysis power of `xts`, `quantmod` and `TTR`, with an
* I/O built to be scaled with the `tidyverse` workflow. 

With a few, easy-to-use core functions, you can efficiently leverage the quantitative power of `xts`, `quantmod` and `TTR` with the data management infrastructure and scale-ability of the `tidyverse`. 

