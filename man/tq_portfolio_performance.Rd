% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tq_portfolio_performance.R
\name{tq_portfolio_performance}
\alias{tq_portfolio_performance}
\title{Calculate portfolio level metrics that depend on component level interactions}
\usage{
tq_portfolio_performance(data, assets_col, returns_col, performance_fun,
  weights = NULL, ...)
}
\arguments{
\item{data}{A \code{tibble} (tidy data frame) of returns in tidy format (i.e long format).}

\item{assets_col}{The column with assets (securities)}

\item{returns_col}{The column with returns}

\item{performance_fun}{A portfolio performance metric function. See
\code{tq_portfolio_performance_fun_options()} for available options.}

\item{weights}{Asset weights, which can be passed as a numeric vector the
length of the number of assets or a two column tibble with asset names in
first column and weights in second column. With 1 portfolio, this is optional,
with multiple portfolios, this is required.}

\item{...}{Additional parameters passed to the appropriate
\code{PerformanceAnalytics} function.}
}
\value{
Returns a summary \code{tibble} of the portfolio metric results.
}
\description{
Calculations like portfolio standard deviation and value at risk are influenced
by the individual assets that make up the portfolio through their correlation
with each other. \code{tq_portfolio_performance()} allows the user to take those
correlations into account.
}
\details{
\code{tq_portfolio_performance()} is a wrapper for \code{PerformanceAnalytics} functions
that calculate metrics taking into account the individual correlations
between assets. These functions are \code{PerformanceAnalytics::VaR()} (Value at Risk),
\code{PerformanceAnalytics::StdDev()} (Standard Deviation),
and \code{PerformanceAnalytics::ES()} (Expected Shortfall).

Each of the three functions listed above take a number of arguments that
change the output and affect how the calculations are performed. Most important
are the \code{method} and \code{portfolio_method} arguments which can be passed
through the \code{...} argument. Read the documentation for each function to
know what methods are supported.

For multiple portfolios, \code{\link[=tq_repeat_df]{tq_repeat_df()}} is a helper function to put
your weight and asset return tibbles into the correct format. See the
examples for details.

\code{assets_col} and \code{returns_col} are columns within \code{data} that are used
to compute returns for a portfolio. The columns should be in "long" format (or "tidy" format)
meaning there is only one column containing all of the assets and one column containing
all of the return values (i.e. not in "wide" format with returns spread by asset).

\code{weights} are the weights to be applied to the asset returns.
Weights can be input in one of three options:
\itemize{
\item Single Portfolio: A numeric vector of weights that is the same length as unique number of assets.
The weights are applied in the order of the assets.
\item Single Portfolio: A two column tibble with assets in the first column and weights in the second column.
The advantage to this method is the weights are mapped to the assets and any unlisted
assets default to a weight of zero.
\item Multiple Portfolios: A three column tibble with portfolio index in the first
column, assets in the second column, and weights in the third column. The tibble
must be grouped by portfolio index.
}
}
\examples{

# Load libraries
library(tidyquant)

# Use FANG data set
data(FANG)

# Get returns for individual stock components
monthly_returns_stocks <- FANG \%>\%
    group_by(symbol) \%>\%
    tq_transmute(adjusted, periodReturn, period = "monthly")

##### Portfolio Aggregation Methods #####

# Method 1: Use tq_portfolio_performance with numeric vector of weights

weights <- c(0.50, 0.25, 0.25, 0)

# Calculating portfolio standard deviation
tq_portfolio_performance(data = monthly_returns_stocks,
                         assets_col = symbol,
                         returns_col = monthly.returns,
                         weights = weights,
                         performance_fun = StdDev)

# Calculating portfolio standard deviation and asking for
# component level risk attribution
tq_portfolio_performance(data = monthly_returns_stocks,
                         assets_col = symbol,
                         returns_col = monthly.returns,
                         weights = weights,
                         performance_fun = StdDev,
                         portfolio_method = "component")

# If no weights are specified, the default is to calculate the
# standard deviation of each asset separately
tq_portfolio_performance(data = monthly_returns_stocks,
                         assets_col = symbol,
                         returns_col = monthly.returns,
                         performance_fun = StdDev)

# Method 2: Use tq_portfolio with two column tibble and map weights

# Note that GOOG's weighting is zero in Method 1. In Method 2,
# GOOG is not added and same result is achieved.
weights_df <- tibble(symbol = c("FB", "AMZN", "NFLX"),
                     weights = c(0.50, 0.25, 0.25))

# Calculate portfolio value at risk with risk contribution
tq_portfolio_performance(data = monthly_returns_stocks,
                         assets_col = symbol,
                         returns_col = monthly.returns,
                         weights = weights_df,
                         performance_fun = VaR,
                         portfolio_method = "component")

# Unlike StdDev, VaR will produce an error if you attempt to
# calculate portfolio VaR with weights, but without specifying
# portfolio_method = "component". The default portfolio_method = "single"
# which would be used below fails in this case.
# tq_portfolio_performance(data = monthly_returns_stocks,
#              assets_col = symbol,
#              returns_col = monthly.returns,
#              weights = weights_df,
#              performance_fun = VaR)

# Method 3: Working with multiple portfolios

# 3A: Duplicate monthly_returns_stocks multiple times
mult_monthly_returns_stocks <- tq_repeat_df(monthly_returns_stocks, n = 4)

# 3B: Create weights table grouped by portfolio id
weights <- c(0.50, 0.25, 0.25, 0.00,
             0.00, 0.50, 0.25, 0.25,
             0.25, 0.00, 0.50, 0.25,
             0.25, 0.25, 0.00, 0.50)
stocks <- c("FB", "AMZN", "NFLX", "GOOG")
weights_table <- tibble(stocks) \%>\%
    tq_repeat_df(n = 4) \%>\%
    bind_cols(tibble(weights)) \%>\%
    group_by(portfolio)

# 3C: Scale to multiple portfolios

# Expected Shortfall with risk attribution for each of the 4
# portfolios
tq_portfolio_performance(data = mult_monthly_returns_stocks,
                         assets_col = symbol,
                         returns_col = monthly.returns,
                         weights = weights_table,
                         performance_fun = ES,
                         portfolio_method = "component")

# Like the VaR example, you must specify portfolio_method = "component"
# when supplying weights.

# You must also always supply weights when using multiple portfolios

}
\seealso{
\code{\link[=tq_repeat_df]{tq_repeat_df()}}, and \code{\link[=tq_portfolio]{tq_portfolio()}}
}
